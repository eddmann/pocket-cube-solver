{"version":3,"sources":["App.module.css","App.tsx","CameraControls.tsx","Cube/Face.tsx","Cube/Cubie.tsx","Cube/animation.ts","Cube/index.tsx","index.tsx"],"names":["module","exports","SOLVED_CUBE","Actions","state","onStateChange","onRandom","onSolve","className","styles","size","type","value","match","join","onChange","e","target","toUpperCase","replace","onClick","Solutions","solution","solutionIdx","isAutoPlay","onMoveSelection","onAutoPlay","length","Solution","map","idx","move","ActiveMove","Move","checked","App","solver","cubeRef","useRef","useState","setState","setSolution","setSolutionIdx","setAutoPlay","useEffect","current","endState","isActiveAnimation","rotate","then","reset","rand_cube","solve_cube","Promise","resolve","apply_cube_moves","slice","error","reject","doSolve","catch","global","alert","Canvas","camera","position","gl","antialias","ref","startState","extend","OrbitControls","CameraControls","useThree","controls","useFrame","update","args","domElement","enableDamping","dampingFactor","enableZoom","enableKeys","enablePan","minDistance","maxDistance","eps","Face","width","height","radius","inverse","colour","shape","useMemo","radius0","Shape","absarc","Math","PI","createShape","rotY","rotX","Vector3","setX","setY","setZ","meshRef","geometryRef","React","useLayoutEffect","rotateX","rotateY","center","color","side","DoubleSide","polygonOffset","transparent","polygonOffsetFactor","polygonOffsetUnits","attach","RoundedBox","forwardRef","depth","smoothness","children","rest","params","bevelEnabled","bevelSegments","steps","bevelSize","bevelThickness","curveSegments","geomRef","Cubie","sideColour","topColour","frontColour","userData","x","y","z","operations","displayName","plane","direction","layers","quarterTurns","pivotPoint","planePermutations","id","name","getCubiesForPlane","cubies","numLayers","results","coordinateMatches","coordinateSelector","coordinate","planeSelector","forEach","cubie","i","j","k","coordinatesMatch","push","animate","animationSpeed","operation","find","op","Error","targetRotation","remaining","cubiesToRotate","step","stepFactor","theta","pow","applyAxisAngle","rotateOnAxis","CUBIE_POSITIONS","STATE_LOOKUP","COLOURS","W","O","G","R","Y","B","Cube","cubiesRef","animationRef","stateWithPadding","padEnd","cubieColours","split","reduce","faces","face","animation","onCompletion","undefined","copy","rotation","set","useImperativeHandle","offset","top","front","el","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.4c045743.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"Canvas\":\"App_Canvas__15Nu5\",\"Actions\":\"App_Actions__2exsc\",\"Solution\":\"App_Solution__3shAa\",\"Move\":\"App_Move__1PhE9\",\"ActiveMove\":\"App_ActiveMove__1IpDk\"};","import React, { useState, useRef, useEffect } from 'react';\nimport { Canvas } from '@react-three/fiber';\nimport CameraControls from './CameraControls';\nimport Cube from './Cube';\nimport styles from './App.module.css';\n\nconst SOLVED_CUBE = 'WWWWOOOOGGGGRRRRYYYYBBBB';\nconst SOLVED_MOVE = 'ðŸŽ‰';\n\ntype AppProps = {\n  solver: any;\n};\n\ntype Solution = [\n  move: string,\n  startState: string,\n  endState: string\n][];\n\nconst doSolve = (solver: any, state: string): Promise<Solution> => {\n  try {\n    const solution = solver.solve_cube(state);\n\n    return Promise.resolve([\n      ...solution.map((move: string, idx: number) => [\n        move,\n        solver.apply_cube_moves(state, solution.slice(0, idx)),\n        solver.apply_cube_moves(state, solution.slice(0, idx + 1)),\n      ]),\n      [SOLVED_MOVE, SOLVED_CUBE, SOLVED_CUBE],\n    ]);\n  } catch (error) {\n    return Promise.reject(error);\n  }\n};\n\nconst App = ({ solver }: AppProps) => {\n  const cubeRef = useRef<any>();\n  const [state, setState] = useState(SOLVED_CUBE);\n  const [solution, setSolution] = useState<Solution>([]);\n  const [solutionIdx, setSolutionIdx] = useState(0);\n  const [isAutoPlay, setAutoPlay] = useState(true);\n\n  useEffect(() => {\n    if (!cubeRef.current) return;\n    if (!solution[solutionIdx]) return;\n    if (!isAutoPlay) return;\n\n    const [move, , endState] = solution[solutionIdx];\n    if (move === SOLVED_MOVE) return;\n\n    let isActiveAnimation = true;\n\n    cubeRef.current.rotate(move).then(() => {\n      if (!isActiveAnimation) {\n        cubeRef.current.reset();\n        return;\n      }\n\n      setState(endState);\n\n      if (solutionIdx + 1 < solution.length) {\n        setSolutionIdx(solutionIdx + 1);\n      }\n    });\n\n    return () => {\n      isActiveAnimation = false;\n    };\n  }, [solution, solutionIdx, isAutoPlay]);\n\n  const handleRandom = () => {\n    setState(solver.rand_cube());\n    setSolution([]);\n    setSolutionIdx(0);\n  };\n\n  const handleSolve = () => {\n    doSolve(solver, state)\n      .then(solution => {\n        setSolution(solution);\n        setSolutionIdx(0);\n        setAutoPlay(true);\n      })\n      .catch(error => {\n        global.alert(error);\n      });\n  };\n\n  const handleMoveSelection = (idx: number) => {\n    const [, startState] = solution[idx];\n    setState(startState);\n    setSolutionIdx(idx);\n  };\n\n  return (\n    <div>\n      <header>\n        <h1>Pocket Cube Solver</h1>\n      </header>\n      <Actions\n        state={state}\n        onStateChange={setState}\n        onRandom={handleRandom}\n        onSolve={handleSolve}\n      />\n      <Canvas\n        className={styles.Canvas}\n        camera={{ position: [4, 4, 5] }}\n        gl={{ antialias: true }}\n      >\n        <CameraControls />\n        <Cube ref={cubeRef} state={state} />\n      </Canvas>\n      <Solutions\n        solution={solution}\n        solutionIdx={solutionIdx}\n        isAutoPlay={isAutoPlay}\n        onMoveSelection={handleMoveSelection}\n        onAutoPlay={setAutoPlay}\n      />\n    </div>\n  );\n};\n\ntype ActionsProps = {\n  state: string;\n  onStateChange: (state: string) => void;\n  onRandom: () => void;\n  onSolve: () => void;\n};\n\nconst Actions = ({\n  state,\n  onStateChange,\n  onRandom,\n  onSolve,\n}: ActionsProps) => {\n  return (\n    <div className={styles.Actions}>\n      <input\n        size={40}\n        type=\"text\"\n        value={(state.match(/.{1,4}/g) || []).join(' ')}\n        onChange={e =>\n          onStateChange(\n            e.target.value.toUpperCase().replace(/[^WOGRYB]/g, '')\n          )\n        }\n      />\n      <button onClick={onRandom}>Random</button>\n      <button onClick={onSolve}>Solve</button>\n    </div>\n  );\n};\n\ntype SolutionsProps = {\n  solution: Solution;\n  solutionIdx: number;\n  isAutoPlay: boolean;\n  onMoveSelection: (idx: number) => void;\n  onAutoPlay: (enabled: boolean) => void;\n};\n\nconst Solutions = ({\n  solution,\n  solutionIdx,\n  isAutoPlay,\n  onMoveSelection,\n  onAutoPlay,\n}: SolutionsProps) => {\n  if (solution.length === 0) {\n    return null;\n  }\n\n  return (\n    <div className={styles.Solution}>\n      {solution.map(([move]: any, idx: number) => (\n        <span\n          key={idx}\n          className={\n            solutionIdx === idx ? styles.ActiveMove : styles.Move\n          }\n          onClick={() => onMoveSelection(idx)}\n        >\n          {move}\n        </span>\n      ))}\n      <label>\n        <input\n          type=\"checkbox\"\n          onChange={() => onAutoPlay(!isAutoPlay)}\n          checked={isAutoPlay}\n        />\n        Auto Play\n      </label>\n    </div>\n  );\n};\n\nexport default App;\n","import React, { useRef } from 'react';\nimport {\n  useFrame,\n  useThree,\n  extend,\n  ReactThreeFiber,\n} from '@react-three/fiber';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls';\n\nextend({ OrbitControls });\n\ndeclare global {\n  namespace JSX {\n    interface IntrinsicElements {\n      orbitControls: ReactThreeFiber.Object3DNode<\n        OrbitControls,\n        typeof OrbitControls\n      >;\n    }\n  }\n}\n\nconst CameraControls = () => {\n  const { camera, gl } = useThree();\n\n  const controls = useRef<OrbitControls>();\n  useFrame(() => controls.current?.update());\n\n  return (\n    <orbitControls\n      ref={controls}\n      args={[camera, gl.domElement]}\n      enableDamping={true}\n      dampingFactor={0.25}\n      enableZoom={true}\n      enableKeys={false}\n      enablePan={false}\n      minDistance={4}\n      maxDistance={4}\n    />\n  );\n};\n\nexport default CameraControls;\n","import React, { useMemo, useRef } from 'react';\nimport { Shape, DoubleSide, Vector3 } from 'three';\n\nconst eps = 0.00001;\n\nconst createShape = (\n  width: number,\n  height: number,\n  radius0: number\n): Shape => {\n  const shape = new Shape();\n  const radius = radius0 - eps;\n\n  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\n  shape.absarc(\n    eps,\n    height - radius * 2,\n    eps,\n    Math.PI,\n    Math.PI / 2,\n    true\n  );\n  shape.absarc(\n    width - radius * 2,\n    height - radius * 2,\n    eps,\n    Math.PI / 2,\n    0,\n    true\n  );\n  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\n\n  return shape;\n};\n\ntype FaceProps = {\n  width?: number;\n  height?: number;\n  radius?: number;\n  type: 'side' | 'top' | 'front';\n  colour: string;\n  inverse: boolean;\n};\n\nconst Face = ({\n  width = 0.88,\n  height = 0.88,\n  radius = 0,\n  type,\n  inverse,\n  colour,\n}: FaceProps) => {\n  const shape = useMemo(() => createShape(width, height, radius), [\n    width,\n    height,\n    radius,\n  ]);\n\n  let rotY = 0;\n  let rotX = 0;\n  const position = new Vector3(0, 0, 0);\n\n  switch (type) {\n    case 'side':\n      rotY = (inverse ? -1 : 1) * (Math.PI / 2);\n      position.setX(inverse ? -0.5 : 0.5);\n      break;\n    case 'top':\n      rotX = (inverse ? 1 : -1) * (Math.PI / 2);\n      position.setY(inverse ? -0.5 : 0.5);\n      break;\n    case 'front':\n      rotY = Math.PI;\n      position.setZ(inverse ? -0.5 : 0.5);\n      break;\n  }\n\n  const meshRef = useRef<THREE.Mesh>();\n  const geometryRef = useRef<THREE.ShapeBufferGeometry>();\n\n  React.useLayoutEffect(() => {\n    meshRef.current?.rotateX(rotX);\n    meshRef.current?.rotateY(rotY);\n    geometryRef.current?.center();\n  }, [rotY, rotX]);\n\n  return (\n    <mesh ref={meshRef} position={position}>\n      <meshBasicMaterial\n        color={colour}\n        side={DoubleSide}\n        polygonOffset\n        transparent\n        polygonOffsetFactor={-1}\n        polygonOffsetUnits={-4}\n      />\n      <shapeBufferGeometry\n        ref={geometryRef}\n        attach=\"geometry\"\n        args={[shape, 5]}\n      />\n    </mesh>\n  );\n};\n\nexport default Face;\n","import React, { forwardRef } from 'react';\nimport { Shape, ExtrudeBufferGeometry, Mesh, Vector3 } from 'three';\nimport Face from './Face';\n\nconst eps = 0.00001;\n\nconst createShape = (\n  width: number,\n  height: number,\n  radius0: number\n) => {\n  const shape = new Shape();\n  const radius = radius0 - eps;\n\n  shape.absarc(eps, eps, eps, -Math.PI / 2, -Math.PI, true);\n  shape.absarc(\n    eps,\n    height - radius * 2,\n    eps,\n    Math.PI,\n    Math.PI / 2,\n    true\n  );\n  shape.absarc(\n    width - radius * 2,\n    height - radius * 2,\n    eps,\n    Math.PI / 2,\n    0,\n    true\n  );\n  shape.absarc(width - radius * 2, eps, eps, 0, -Math.PI / 2, true);\n\n  return shape;\n};\n\ntype RoundBoxProps = {\n  args?: [width?: number, height?: number, depth?: number];\n  radius?: number;\n  smoothness?: number;\n} & Omit<JSX.IntrinsicElements['mesh'], 'args'>;\n\nconst RoundedBox = forwardRef<Mesh, RoundBoxProps>(\n  function RoundedBox(\n    {\n      args: [width = 1, height = 1, depth = 1] = [],\n      radius = 0.05,\n      smoothness = 4,\n      children,\n      ...rest\n    },\n    ref\n  ) {\n    const shape = React.useMemo(\n      () => createShape(width, height, radius),\n      [width, height, radius]\n    );\n    const params = React.useMemo(\n      () => ({\n        depth: depth - radius * 2,\n        bevelEnabled: true,\n        bevelSegments: smoothness * 2,\n        steps: 1,\n        bevelSize: radius - eps,\n        bevelThickness: radius,\n        curveSegments: smoothness,\n      }),\n      [depth, radius, smoothness]\n    );\n    const geomRef = React.useRef<ExtrudeBufferGeometry>();\n\n    React.useLayoutEffect(() => {\n      if (geomRef.current) {\n        geomRef.current.center();\n      }\n    }, [shape, params]);\n\n    return (\n      <mesh ref={ref} {...rest}>\n        <extrudeBufferGeometry\n          attach=\"geometry\"\n          ref={geomRef}\n          args={[shape, params]}\n        />\n        {children}\n      </mesh>\n    );\n  }\n);\n\ntype CubieProps = {\n  position: Vector3;\n  sideColour: string;\n  topColour: string;\n  frontColour: string;\n};\n\nconst Cubie = forwardRef<Mesh, CubieProps>(\n  ({ position, sideColour, topColour, frontColour }, ref) => {\n    return (\n      <RoundedBox\n        ref={ref}\n        args={[1, 1, 1]}\n        radius={0.08}\n        smoothness={5}\n        position={position}\n        userData={{ position }}\n      >\n        <meshBasicMaterial color={0x000000} />\n        <Face\n          type=\"side\"\n          inverse={position.x < 0}\n          colour={sideColour}\n        />\n        <Face\n          type=\"top\"\n          inverse={position.y < 0}\n          colour={topColour}\n        />\n        <Face\n          type=\"front\"\n          inverse={position.z < 0}\n          colour={frontColour}\n        />\n      </RoundedBox>\n    );\n  }\n);\n\nexport default Cubie;\n","import { Vector3 } from 'three';\n\n// prettier-ignore\nconst operations = [\n  { displayName: \"F\",  plane: 0, direction: -1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(0, 0, 1) },\n  { displayName: \"F'\", plane: 0, direction:  1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(0, 0, 1) },\n  { displayName: \"B\",  plane: 1, direction: -1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(0, 0, 1) },\n  { displayName: \"B'\", plane: 1, direction:  1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(0, 0, 1) },\n  { displayName: \"U\",  plane: 2, direction: -1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(0, 1, 0) },\n  { displayName: \"U'\", plane: 2, direction:  1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(0, 1, 0) },\n  { displayName: \"D\",  plane: 3, direction: -1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(0, 1, 0) },\n  { displayName: \"D'\", plane: 3, direction:  1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(0, 1, 0) },\n  { displayName: \"L\",  plane: 4, direction: -1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(1, 0, 0) },\n  { displayName: \"L'\", plane: 4, direction:  1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(1, 0, 0) },\n  { displayName: \"R\",  plane: 5, direction: -1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(1, 0, 0) },\n  { displayName: \"R'\", plane: 5, direction:  1, layers:  1, quarterTurns: 1, pivotPoint: new Vector3(1, 0, 0) },\n  { displayName: \"F2\", plane: 0, direction:  1, layers:  1, quarterTurns: 2, pivotPoint: new Vector3(0, 0, 1) },\n  { displayName: \"B2\", plane: 1, direction:  1, layers:  1, quarterTurns: 2, pivotPoint: new Vector3(0, 0, 1) },\n  { displayName: \"U2\", plane: 2, direction:  1, layers:  1, quarterTurns: 2, pivotPoint: new Vector3(0, 1, 0) },\n  { displayName: \"D2\", plane: 3, direction:  1, layers:  1, quarterTurns: 2, pivotPoint: new Vector3(0, 1, 0) },\n  { displayName: \"L2\", plane: 4, direction:  1, layers:  1, quarterTurns: 2, pivotPoint: new Vector3(1, 0, 0) },\n  { displayName: \"R2\", plane: 5, direction:  1, layers:  1, quarterTurns: 2, pivotPoint: new Vector3(1, 0, 0) },\n];\n\nconst planePermutations = [\n  { id: 0, name: 'F', center: [0, 0, 0.5] },\n  { id: 1, name: 'B', center: [0, 0, -0.5] },\n  { id: 2, name: 'U', center: [0, 0.5, 0] },\n  { id: 3, name: 'D', center: [0, 0.5, 0] },\n  { id: 4, name: 'L', center: [-0.5, 0, 0] },\n  { id: 5, name: 'R', center: [0.5, 0, 0] },\n];\n\nconst getCubiesForPlane = (\n  cubies: any[],\n  plane: number,\n  numLayers: number\n) => {\n  const results: any[] = [];\n\n  function coordinateMatches(\n    coordinateSelector: number,\n    coordinate: number,\n    numLayers: number\n  ) {\n    switch (numLayers) {\n      case -1:\n        // middle layer\n        return coordinateSelector === 0 || coordinate === 0;\n\n      case 1:\n        // just pivot layer\n        return (\n          coordinateSelector === 0 ||\n          coordinateSelector === coordinate\n        );\n      case 2:\n        // pivot layer and the middle layer\n        return (\n          coordinateSelector === 0 ||\n          coordinateSelector === coordinate ||\n          coordinate === 0\n        );\n      case 3:\n        // whole cube\n        return true;\n    }\n  }\n\n  const planeSelector = planePermutations[plane].center;\n\n  function coordinatesMatch(\n    i: number,\n    j: number,\n    k: number,\n    numLayers: number\n  ) {\n    return (\n      coordinateMatches(planeSelector[0], i, numLayers) &&\n      coordinateMatches(planeSelector[1], j, numLayers) &&\n      coordinateMatches(planeSelector[2], k, numLayers)\n    );\n  }\n\n  cubies.forEach(cubie => {\n    const { position } = cubie.userData;\n    if (\n      coordinatesMatch(position.x, position.y, position.z, numLayers)\n    ) {\n      results.push(cubie);\n    }\n  });\n\n  return results;\n};\n\nexport type Animation = {\n  step: () => boolean;\n};\n\nconst animate = (\n  cubies: any[],\n  move: string,\n  animationSpeed: number\n): Animation => {\n  const operation = operations.find(op => op.displayName === move);\n\n  if (!operation) {\n    throw new Error();\n  }\n\n  const {\n    plane,\n    direction,\n    layers,\n    quarterTurns,\n    pivotPoint,\n  } = operation;\n\n  const targetRotation = (quarterTurns * Math.PI) / 2;\n  let remaining = targetRotation;\n\n  const cubiesToRotate = getCubiesForPlane(cubies, plane, layers);\n\n  return {\n    step() {\n      if (remaining <= 0) {\n        return false;\n      }\n\n      const stepFactor = 0.05 * quarterTurns * animationSpeed;\n      const theta =\n        (1.1 -\n          Math.pow(\n            (2 * remaining - targetRotation) / targetRotation,\n            2\n          )) *\n        stepFactor;\n      remaining -= theta;\n\n      cubiesToRotate.forEach(cubie => {\n        cubie.position.applyAxisAngle(pivotPoint, theta * direction);\n        cubie.rotateOnAxis(pivotPoint, theta * direction);\n      });\n\n      return true;\n    },\n  };\n};\n\nexport default animate;\n","import React, {\n  useRef,\n  useLayoutEffect,\n  useImperativeHandle,\n  forwardRef,\n} from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport { Vector3 } from 'three';\nimport Cubie from './Cubie';\nimport animate, { Animation } from './animation';\n\nconst FACE_SIDES = 3;\n\nconst CUBIE_POSITIONS = [\n  new Vector3(-0.5, -0.5, -0.5),\n  new Vector3(-0.5, -0.5, 0.5),\n  new Vector3(-0.5, 0.5, -0.5),\n  new Vector3(-0.5, 0.5, 0.5),\n  new Vector3(0.5, -0.5, -0.5),\n  new Vector3(0.5, -0.5, 0.5),\n  new Vector3(0.5, 0.5, -0.5),\n  new Vector3(0.5, 0.5, 0.5),\n];\n\n// prettier-ignore\nconst STATE_LOOKUP = [\n  7, 19, 22, 10, 6, 9, 3, 0, 11, 23, 17, 5,\n  21, 18, 12, 15, 4, 16, 13, 1, 20, 8, 2, 14\n];\n\nconst COLOURS = {\n  W: 'white',\n  O: 'orange',\n  G: 'green',\n  R: 'red',\n  Y: 'yellow',\n  B: 'blue',\n};\n\ntype CubeProps = {\n  state: string;\n};\n\nconst Cube = forwardRef<THREE.Group, CubeProps>(({ state }, ref) => {\n  const cubiesRef = useRef<THREE.Mesh[]>([]);\n  const animationRef = useRef<[Animation, () => void]>();\n\n  const stateWithPadding = state.padEnd(24, 'W');\n  const cubieColours = stateWithPadding\n    .split('')\n    .reduce((faces, face, idx) => {\n      // @ts-ignore\n      faces[STATE_LOOKUP[idx]] = COLOURS[face];\n      return faces;\n    }, []);\n\n  useFrame(() => {\n    if (!animationRef.current) return;\n\n    const [animation, onCompletion] = animationRef.current;\n\n    if (!animation.step()) {\n      onCompletion();\n      animationRef.current = undefined;\n    }\n  });\n\n  const rotate = (move: string) =>\n    new Promise<void>(resolve => {\n      animationRef.current = [\n        animate(cubiesRef.current, move, 1),\n        resolve,\n      ];\n    });\n\n  const reset = () => {\n    cubiesRef.current.forEach(cubie => {\n      cubie.position.copy(cubie.userData.position);\n      cubie.rotation.set(0, 0, 0);\n    });\n  };\n\n  useLayoutEffect(reset, [stateWithPadding]);\n\n  // @ts-ignore\n  useImperativeHandle(ref, () => ({ reset, rotate }));\n\n  return (\n    <group ref={ref}>\n      {CUBIE_POSITIONS.map((position, idx) => {\n        const offset = idx * FACE_SIDES;\n        const [side, top, front] = cubieColours.slice(\n          offset,\n          offset + FACE_SIDES\n        );\n\n        return (\n          <Cubie\n            key={idx}\n            // @ts-ignore\n            ref={el => (cubiesRef.current[idx] = el)}\n            position={position}\n            sideColour={side}\n            topColour={top}\n            frontColour={front}\n          />\n        );\n      })}\n    </group>\n  );\n});\n\nexport default Cube;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nimport './new-1.1.3.css';\n\nimport('wasm-pocket-cube-solver').then(solver => {\n  ReactDOM.render(\n    <React.StrictMode>\n      <App solver={solver} />\n    </React.StrictMode>,\n    document.getElementById('root')\n  );\n});\n"],"sourceRoot":""}